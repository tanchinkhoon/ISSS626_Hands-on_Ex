---
title: "In-class Ex08: Take-home Exercise 3 Kick Starter"
author: "TAN Chin Khoon"
date: "25 October 2025"
number-sections: true
date-modified: "25 October 2025"
---

## Learning Outcomes

By the end of this in-class exercise, students will master the skill of:

- prepare and geocode HDB resale price data for geospatial modelling; and
- perform proximity analysis to count the number of geographic entities located within a defined distance from each HDB property.

## Installing and Loading R Packages

```{r}

# Create/load all required packages in one shot
pacman::p_load(httr,tidyverse, sf, tmap,jsonlite, progress, spdep,GWmodel, SpatialML, rsample, Metrics, knitr, kableExtra, spatialRF, randomForestExplainer)

```

## Geocoding for Geometric

### Importing data 

```{r}

# Downloading the raw data from data.gov.sg. 
# Data source: Resale flat prices based on registration date from Jan-2017 onwards

# load full table once
HDBresale_raw <- read_csv("/Users/cktan/Desktop/SMU/01_Geospatial Analytics (ISSS626)/Hands-on_Ex/In-Class_Ex08/data/rawdata/ResaleflatpricesbasedonregistrationdatefromJan2017onwards.csv")

# Inspect the loading data
glimpse(HDBresale_raw)


```

### Reducing and filtering the dataset

```{r}

# find the most recent month that has 4 ROOM
month_choice <- HDBresale_raw %>%
  filter(flat_type == "4 ROOM") %>%
  count(month, name = "n") %>%
  filter(n > 0) %>%
  arrange(desc(month)) %>%
  slice(1) %>%
  pull(month)

#Inspect the output
month_choice

```


```{r}

# filter to that month
HDBresale <- HDBresale_raw %>%
  filter(flat_type == "4 ROOM", month == month_choice)

nrow(HDBresale)   # should be greater than zero

```

### Geodata pre-processing and cleaning

#### Address normalisation matters

```{r}

# street name fix
HDBresale$street_name <- gsub("ST\\.", "SAINT", HDBresale$street_name)

```

:::{.callout-note}

The `gsub()` function performs a global substitution (find and replace) in text.

:::

#### Function to convert address to coordinates (LATITUDE and LONGITUDEY)

Below is the code chunk used to build a function that will convert address to coordinates

- The function sends a live API request to OneMap Singapore to obtain geographic coordinates (latitude and longitude) for each given HDB address.  
- Explicit UTF-8 encoding is included to eliminate the “No encoding supplied” warning and ensure correct text handling for special characters.  
- Always returns a tibble with columns LATITUDE and LONGITUDE, even when no match is found, to prevent pipeline breaks during unnesting.  
- Only retrieves the first match from the API (pageNum = "1"), which increases speed but may ignore alternative results for ambiguous addresses.  
- Requires street name standardisation (e.g., “ST.” changed to “SAINT”) before calling the function to improve matching accuracy.  
- Coordinates returned by OneMap are based on WGS84 (EPSG 4326), so conversion to SVY21 (EPSG 3414) is needed for metric-based distance analysis.  
- Each function call makes a separate HTTP request; for large datasets, use progress tracking, pauses (Sys.sleep), and checkpoint saving to avoid rate limits.  
- Wrapping the function with tryCatch or purrr::safely prevents process interruption if a request fails or the API returns an unexpected response.  
- A test call such as geocode("101","JURONG EAST STREET 13") is recommended before batch processing to confirm valid numeric coordinates are returned.  
- For reproducibility and efficiency, store results (block, street, LATITUDE, LONGITUDE) in a CSV file to reuse in future runs without re-querying the API.

```{r}

# professor geocode
# Reference: https://www.onemap.gov.sg/apidocs/coordinate


geocode <- function(block, streetname) {                          # define a function that takes block and street name and returns coordinates
  base_url <- "https://onemap.gov.sg/api/common/elastic/search"   # store the OneMap search endpoint as a constant for reuse
  address  <- paste(block, streetname, sep = " ")                 # build a single query string such as 118 ANG MO KIO AVENUE 4
  query <- list(                                                  # create a named list of query parameters for the HTTP request
    searchVal     = address,                                      # the address string to search
    returnGeom    = "Y",                                          # ask the service to return geometry fields
    getAddrDetails= "N",                                          # do not request extra address fields to keep reply small
    pageNum       = "1"                                           # take the first page only for a single best match
  )                                                               # end of query parameter list
  res     <- httr::GET(base_url, query = query)                   # send a GET request to OneMap with the query parameters
  restext <- httr::content(res, as = "text", encoding = "UTF-8")  # read the response body as text with UTF8 to avoid encoding warnings
  out     <- jsonlite::fromJSON(restext)                          # parse the JSON text into an R list or data frame

  if (length(out$results) == 0) {                                 # if the service returns no match for this address
    tibble(LATITUDE = NA_real_, LONGITUDE = NA_real_)             # return a tibble with missing numeric coordinates
  } else {                                                        # otherwise when there is at least one match
    tibble(                                                              
      LATITUDE  = as.numeric(out$results$LATITUDE[1]),            # take the first result latitude and coerce to numeric
      LONGITUDE = as.numeric(out$results$LONGITUDE[1])            # take the first result longitude and coerce to numeric
    )                                                             # end tibble creation
  }                                                               # end branch
}                                                                 # end function

```

#### Perform minimal unit/smoke test

```{r}

# Test with a single known HDB address
geocode("101", "JURONG EAST STREET 13")

```

### Merge the LATITUDE and LONGITUDE to dataset

```{r}

# create LATITUDE and LONGITUDE and merge into the table
HDBresale <- HDBresale %>%
  mutate(geo = purrr::map2(block, street_name, geocode)) %>%
  tidyr::unnest(geo)

### 
glimpse(HDBresale)   # now includes LATITUDE and LONGITUDE

```

## Proximity Analysis

In this section, you will learn how to count the number of geographic entities located within a defined distance from each HDB property.

For the purpose of this exercise, we are interested to count the number of preschools located with 350m of each resale HDB unit.

### Convert to an sf object

Before performing proximity analysis, it is important to ensure that:

- both input data sets must be in sf objects, and
- they must be in similar projected coordinates systems.

:::{.callout-note}

In the code chunk below,

- `st_as_sf()` is used to convert HDBresale tibble data.frame to sf object by using values from LONGITUDE and LATITUDE columns to form the geometry features.
- `st_transform()` is then used to transform the sf object into svy21 projected coordinates system.
- the output sf object is called HDBresale_sf. It is in sf **data.frame** format.

:::

```{r}

# Convert to sf object
HDBresale_sf <- HDBresale %>%
  st_as_sf(coords = c("LONGITUDE", "LATITUDE"), crs = 4326) %>%
  st_transform(crs = 3414)

# Inspect and verify the  
glimpse(HDBresale_sf)

```
```{r}

# Check the CRS (Coordinate Reference System)
st_crs(HDBresale_sf)

```

### Locate, download and import Preschool Location data

Next, we will locate and download Pre-Schools Location data from Singapore’s open data portal. There are both geojson and kml version. In this exercise, the kml version will be used.

Then, code chunk below will be used to import the preschool location data into R environment by using `st_read()` of **readr** package.

```{r}

preschool = st_read(
  "/Users/cktan/Desktop/SMU/01_Geospatial Analytics (ISSS626)/Hands-on_Ex/In-Class_Ex08/data/geospatial/PreSchoolsLocation.kml") %>%
  st_transform(crs= 3414)

```

:::{.callout-note}

`st-transform()` of **sf** package is used to transform the preschool sf dataframe from wgs84 geographic coodinates system to svy21 projected coordinates system (i.e. EPSG: 3414)

:::

### Counting number of preschools

Lastly, code chunk below will be used to count the number of pre-schools located within 350m of each HDB property.

```{r}

within_350m <- st_is_within_distance(
  HDBresale_sf, preschool, dist = 350)

HDBresale_sf <- HDBresale_sf %>%
  mutate(WITHIN_350M_PRISCHOOL = map_int(within_350m, length))

```

:::{.callout-note}

- `st_is_within_distance()` of **sf** package is used to determines whether two spatial objects (HDB property and preschool) are within 350m distance of each other. It returns a logical matrix (or a sparse list of indices if sparse = TRUE) indicating for each geometry in HDB property which geometries in preschool are within 350m distance.
- `mutate()` of dplyr is used to create a new field called ***WITHIN_350M_PRISCHOOL***.
- `map_int()` of **purr** package is used to the number of preschools found in the newly created ***WITHIN_350M_PRISCHOOL*** field.

:::

### Computing shortest distance

Instead of counting number of preschools located within 350m of each HDB resale property, code chunk below is used to compute the distance between the nearest preschool from each HDB resale property.

```{r}

HDBresale_sf <- HDBresale_sf %>%
  mutate(
    PROX_PRESCHOOL = as.numeric(
      st_distance(geometry,
                  preschool[st_nearest_feature(
                    geometry, preschool), ], 
                  by_element = TRUE)
      )
    )

```

:::{.callout-note}

The proximity values computed are in metres because svy21 projected coordinates system is in metres.

:::
