---
title: "Hands-on Ex5b"
author: "TAN Chin Khoon"
date: "26 September 2025"
date-modified: "last-modified"
---

# 10 Local Measures of Spatial Autocorrelation

## 10.1 Overview

We will import geospatial and aspatial data for **Hunan Province (county level)**, join attributes, visualise a regional indicator (GDP per capita, GDPPC), build **contiguity** and **distance** spatial weights, and compute two local spatial statistics:

- **Local Moran’s I (LISA)** for cluster/outlier detection.
- **Getis–Ord Gi* for Hot/Cold Spot** analysis (HCSA).

We will then create choropleths for I values, $p$-values, **LISA clusters ($p < 0.05%$)**, and **HCSA clusters ($p < 0.05$)**, plus Moran scatterplots (raw and standardised).

## 10.2 Getting Started

### 10.2.1 The analytical question

In spatial policy, one of the main development objective of the local govenment and planners is to ensure equal distribution of development in the province. Our task in this study, hence, is to apply appropriate spatial statistical methods to discover if development are even distributed geographically. If the answer is **No**. Then, our next question will be “is there sign of spatial clustering?”. And, if the answer for this question is yes, then our next question will be “where are these clusters?”

In this case study, we are interested to examine the spatial pattern of a selected development indicator (i.e. GDP per capita) of Hunan Provice, People Republic of China.(https://en.wikipedia.org/wiki/Hunan)

### 10.2.2 Study area and data

Two data sets will be used in this hands-on exercise, they are:  

- Hunan province administrative boundary layer at county level (Geospatial). This is a geospatial data set in ESRI shapefile format.
- Hunan_2012.csv (Aspatial): This csv file contains selected Hunan’s local development indicators in 2012.

### 10.2.3 Analytical tools

```{r}

# load packages (installs missing ones, then attaches)
pacman::p_load(sf, sfdep, tmap, tidyverse)  # sf for spatial data; sfdep for spatial stats;
                                            # tmap for mapping; tidyverse for wrangling/ggplot

```

## 10.3 Getting the data into R

```{r}

# --- 10.3.1 Import shapefile into R environment -----------------------------

hunan <- 
  st_read(                      # read a spatial layer from disk
    dsn   = "data/geospatial",  # folder containing the shapefile set
    layer = "Hunan"             # layer name (without .shp)
  ) %>% 
  
  # reproject from WGS84 to UTM zone 50N (EPSG:32650)
  # (projected CRS is recommended for spatial analysis)
  st_transform(crs = 32650)        
  

```

::: {.callout-tip}

The raw data is in WGS 84 geographic coordinates system. For geospatial analysis, it is appropriate to use projected coordinates system. In the code chunk above, st_transform() is used to transform Hunan geospatial data from WGS 84 to UTM zone 50N (i.e. EPSG: 32650).

:::

```{r}

# --- 10.3.2 Import CSV into R environment ----------------------------------

hunan2012 <- 
  readr::read_csv("data/aspatial/Hunan_2012.csv")  # read the attribute table (tabular CSV)

```

```{r}

# --- 10.3.3 Join attributes into the sf object ------------------------------

hunan <- 
  left_join(hunan, hunan2012) %>%  # left join by the shared key column(s) (kept from shapefile)
  select(1:4, 7, 15)               # keep only the columns used in this exercise (as per lesson)

```

### 10.3.4 Visualising the regional indicator (equal vs quantile)

```{r}

equal <- tm_shape(hunan) +
  tm_polygons(fill = "GDPPC",
              fill.scale = tm_scale_intervals(
                style = "equal",
                n = 5,
                values = "brewer.blues"),
              fill.legend = tm_legend(
                title = "GDPPC",
                position = tm_pos_in(
                  "left", "bottom"))) + 
  tm_borders(fill_alpha = 0.5) +
  tm_title("Equal interval classification")

quantile <- tm_shape(hunan) +
  tm_polygons(fill = "GDPPC",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5,
                values = "brewer.blues"),
              fill.legend = tm_legend(
                title = "GDPPC",
                position = tm_pos_in(
                  "left", "bottom"))) + 
  tm_borders(fill_alpha = 0.5) +
  tm_title("Quantile interval classification")

tmap_arrange(equal, 
             quantile, 
             asp=1, 
             ncol=2)

```

::: {.callout-note icon=false}

### Does the plot above reveal any outliers or clusters?

- The **Equal interval map** (left) spreads values evenly across 5 fixed ranges. Because the distribution of GDPPC is skewed, many counties fall into the lower classes, and the map appears very light with only a few darker areas. This makes it **difficult to visually spot clear clusters or outliers**, since most counties look similar and variation is compressed.  

- The **Quantile map** (right) divides the counties into 5 groups with equal counts per group. Here, differences are more apparent — some **dark blue areas (highest quantile)** are grouped together, while very light areas (lowest quantile) are also visible. This gives a stronger sense that there may be **regional clustering of high and low GDPPC**, but it’s only suggestive.

**Answer:** The plots hint at spatial variation, but do not confirm outliers or clusters statistically. Especially in the quantile map, you can see that richer counties cluster in the east, while poorer ones appear in the west/south. Still, formal spatial autocorrelation tests (Moran’s I, LISA) are needed to verify.

:::

::: {.callout-note icon=false}

### Does the plot above indicate the presence of hot spots or cold spots?

- By visual impression only, the **dark blue patches in the quantile map** (eastern and central counties) could be **potential hot spots** (high GDPPC areas adjacent to each other).  

- Conversely, **lighter patches** (western/southern counties) could be **cold spots** (low GDPPC areas grouped together).  

- However, these impressions **are not reliable evidence** — classification maps can exaggerate or understate differences depending on method.  

**Answer:** The quantile map suggests possible **hot spots in central/eastern Hunan** and **cold spots in western/southern areas**, but the equal interval map is less informative. These are **hypotheses only** — the next step is to compute **Local Moran’s I and Gi*** to confirm whether these patterns are statistically significant.

:::

> **In summary:** The classification maps are useful exploratory tools. Quantile classification reveals stronger visual contrasts, hinting at clusters of rich and poor counties. But to **answer definitively** about outliers or hot/cold spots, we must proceed to **LISA (Local Moran’s I)** and ***HCSA (Getis–Ord Gi*)** analyses.


## 10.4 Local Indicators of Spatial Association (LISA)

### 10.4.1 Compute contiguity neighbours and row-standardised weights

```{r}

# Create Queen-contiguity neighbours and W-style weights (row-standardised)
wm_q <- hunan %>% 
  mutate(
    nb = st_contiguity(geometry),   # build a neighbours list from touching polygons (Queen)
    wt = st_weights(nb, style = "W"), # row-standardised weights (sum of weights = 1 per region)
    .before = 1                     # place the new columns at the beginning (professor's style)
  )

# Inspect the neighbour structure (how many neighbours per county)
summary(wm_q$nb)  # prints count distribution, min/max, and average links

```
The summary report above shows that there are 88 area units in Hunan. The most connected area unit has 11 neighbours. There are two area units with only one neighbour.

### 10.4.3 Compute Local Moran’s I (permutation nsim = 99)

```{r}

lisa <- wm_q %>% 
  mutate(local_moran = local_moran(
    GDPPC, nb, wt, nsim = 99),
         .before = 1) %>%
  unnest(local_moran)

```

`local_moran()` function returns a matrix of values whose columns are:

- li: the local Moran’s I statistics
- E.li: the expectation of local moran statistic under the randomisation hypothesis
- Var.li: the variance of local moran statistic under the randomisation hypothesis
- Z.Ii:the standard deviate of local moran statistic
- Pr(): the p-value of local moran statistic

```{r}

glimpse(lisa)

```

#### 10.4.3.2 Mapping local Moran’s I values

```{r}

tm_shape(lisa) +
  tm_polygons(fill = "ii",
              fill.scale = tm_scale_intervals(
                style = "pretty",
                n = 5,
                values = "brewer.RdBu"),
              fill.legend = tm_legend(
                title = "Local Morans'I",
                position = tm_pos_out())) + 
  tm_borders(fill_alpha = 0.5) +
  tm_title("Loal Morans'I of GDPPC (Queen's method)")

```

#### 10.4.3.3 Mapping local Moran’s I p-values


```{r}

tm_shape(lisa) +
  tm_polygons(fill = "p_ii", 
              fill.scale = tm_scale_intervals(
                breaks = c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),
                values = "-brewer.Reds"),
              fill.legend = tm_legend(
                title = "p-value",
      position = tm_pos_out())) + 
  tm_borders(fill_alpha = 0.5) +
  tm_title("p-values of Loal Moran's I of GDPPC (Queen's method)")

```

#### 10.4.3.4 Mapping both local Moran’s I values and $p$-values


```{r}

ii.map <- tm_shape(lisa) +
  tm_polygons(fill = "ii",
              fill.scale = tm_scale_intervals(
                style = "pretty",
                n = 5,
                values = "brewer.RdBu"),
              fill.legend = tm_legend(
                title = "Local Moran's I",
                position = tm_pos_in(
                  "left", "bottom"))) + 
  tm_borders(fill_alpha = 0.5) +
  tm_title("Loal Moran's I of GDPPC (Queen's method)")

p_ii.map <- tm_shape(lisa) +
  tm_polygons(fill = "p_ii", 
              fill.scale = tm_scale_intervals(
                breaks = c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),
                values = "-brewer.Reds"),
              fill.legend = tm_legend(
                title = "p-value",
      position = tm_pos_in("left", "bottom")
    )) + 
  tm_borders(fill_alpha = 0.5) +
  tm_title("p-values of Loal Moran's I of GDPPC (Queen's method)")

tmap_arrange(ii.map, p_ii.map, asp=1, ncol=2)

```

### 10.4.4 Preparing and Visualising LISA Map 

#### 10.4.4.1 Plotting Moran scatterplot

```{r}

# --- Compute spatial lag for GDPPC (needed for Moran scatterplot) -----------

lisa <- lisa %>%
  mutate(lag_GDPPC = st_lag(
    GDPPC, nb, wt),
    .before = 1) %>%
  unnest(lag_GDPPC)

```

```{r}

# --- Moran scatterplot (raw values) ----------------------------------------

ggplot(data = lisa, 
       aes(x = GDPPC, 
           y = lag_GDPPC)) +
  geom_point() +
  geom_smooth(method = "lm", 
              se = FALSE, 
              color = "red") +
  labs(x = "GDPPC",
       y = "Spatial Lag of GDPPC",
       title = "Moran Scatterplot") +
  theme_minimal()

```


```{r}

ggplot(data = lisa, 
       aes(x = GDPPC, 
           y = lag_GDPPC, 
           color = mean)) +
  geom_point(size = 2) +
  geom_smooth(method = "lm", 
              se = FALSE, 
              color = "black") +
  geom_hline(yintercept=mean(lisa$lag_GDPPC), lty=2) + 
    geom_vline(xintercept=mean(lisa$GDPPC), lty=2) +
  scale_color_manual(
    values = c("High-High" = "red", 
               "Low-Low" = "blue",
               "Low-High" = "lightblue", 
               "High-Low" = "pink")) +
  labs(x = "GDPPC",
       y = "Spatial Lag of GDPPC",
       title = "Moran Scatterplot with LISA Quadrants") +
  theme_minimal()

```

#### 10.4.4.2 Plotting Moran scatterplot with standardised variable


```{r}

# Standardise GDPPC and its spatial lag (z-scores)
lisa <- lisa %>%
  mutate(
    z_GDPPC     = scale(GDPPC),                # centre & scale GDPPC
    z_lag_GDPPC = scale(lag_GDPPC),            # centre & scale spatial lag
    .before = 1
  )

```


```{r}
# Standardised Moran scatterplot with LISA quadrants
ggplot(data = lisa,
       aes(x = z_GDPPC, y = z_lag_GDPPC, color = mean)) +
  geom_point(size = 2) +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  geom_hline(yintercept = mean(lisa$z_lag_GDPPC), lty = 2) +
  geom_vline(xintercept = mean(lisa$z_GDPPC),      lty = 2) +
  scale_color_manual(values = c("High-High" = "red",
                                "Low-Low"  = "blue",
                                "Low-High" = "lightblue",
                                "High-Low" = "pink")) +
  labs(x = "Standardised GDPPC",
       y = "Standardised Spatial Lag of GDPPC",
       title = "Standardised Moran Scatterplot with LISA Quadrants") +
  theme_minimal()

```

#### 10.4.4.3 Preparing LISA map classes


```{r}

# Significance threshold used by the professor
signif <- 0.05

```

#### 10.4.4.4 Plotting and visualising LISA map

```{r}

# Build the display class for the LISA cluster map (keep only significant locations)
lisa <- lisa %>%
  mutate(
    LISA_cluster = ifelse(p_ii < signif, as.character(mean), "Insignificant"),
    LISA_cluster = factor(LISA_cluster,
                          levels = c("Insignificant","Low-Low","Low-High","High-Low","High-High"))
  )

```



```{r}

lisa_map <- tm_shape(lisa) +
  tm_polygons(
    fill = "LISA_cluster",
    fill.scale = tm_scale_categorical(
      values = c("grey80",  # Insignificant
                 "blue",    # Low-Low
                 "lightblue", # Low-High
                 "pink",    # High-Low
                 "red")     # High-High
    ),
    fill.legend = tm_legend(title = "LISA Cluster",
                            position = tm_pos_in("left","bottom"))
  ) +
  tm_borders() +
  tm_title("Local Moran's I Clusters (p < 0.05)")

lisa_map

```




```{r}

# --- Side-by-side visualisation: Local Moran's I map + LISA Cluster map ----
# Assumes `lisa` already exists from 10.4.3/10.4.4 and contains:
#  - ii       : Local Moran's I statistic
#  - p_ii     : permutation p-values
#  - mean     : LISA quadrant label (High-High, Low-Low, etc.)
#  - LISA_cluster : factor with levels c("Insignificant","Low-Low","Low-High","High-Low","High-High")

# 1) Choropleth of Local Moran's I (Queen's method), using a diverging palette
ii.map <- tm_shape(lisa) +                                           # provide sf object
  tm_polygons(fill = "ii",                                           # map the I statistic
              fill.scale = tm_scale_intervals(                       # classing method and palette
                style = "pretty",                                    # 'pretty' breaks (as in slides)
                n = 5,                                               # 5 classes
                values = "brewer.RdBu"                               # diverging red–blue palette
              ),
              fill.legend = tm_legend(                               # legend style
                title = "Local Moran's I",
                position = tm_pos_in("left","bottom")                # inside, left–bottom
              )) +
  tm_borders(fill_alpha = 0.5) +                                     # light border/fill alpha
  tm_title("Loal Moran's I of GDPPC (Queen's method)")               # title (kept as in slide)

# 2) Choropleth of LISA clusters (significant at p < 0.05)
lisa_map <- tm_shape(lisa) +                                         # same sf object
  tm_polygons(
    fill = "LISA_cluster",                                           # categorical cluster label
    fill.scale = tm_scale_categorical(                               # fixed colours per category
      values = c("grey80",  # Insignificant
                 "blue",    # Low-Low
                 "lightblue", # Low-High
                 "pink",    # High-Low
                 "red")     # High-High
    ),
    fill.legend = tm_legend(                                         # legend style
      title = "LISA Cluster",
      position = tm_pos_in("left","bottom")
    )
  ) +
  tm_borders() +                                                     # polygon borders
  tm_title("Local Moran's I Clusters (p < 0.05)")                    # map title

# 3) Arrange the two maps side by side for comparison
tmap_arrange(ii.map, lisa_map, asp = 1, ncol = 2)                    # equal aspect; two columns


```

::: {.callout-note icon=false}

### What statistical observations can you draw from the LISA map above?


**Statistical observations from the LISA map**

The Local Moran’s I cluster map provides strong evidence of spatial dependence in the distribution of GDP per capita across Hunan Province. Statistically significant **High–High clusters** are observed in the central–eastern part of the province, where wealthy counties are located adjacent to one another. These red-shaded areas indicate local hot spots, confirming that high economic performance is not evenly dispersed but instead forms concentrated pockets of prosperity. Conversely, **Low–Low clusters** are identified in the western counties, representing cold spots where underdeveloped regions are spatially concentrated. These blue-shaded areas highlight localised disadvantage, suggesting that peripheral regions may be experiencing persistent economic stagnation.

In addition, a small number of **outlier counties** appear as **High–Low or Low–High clusters**, where individual counties deviate from the economic profile of their surrounding neighbours. Although fewer in number, these outliers are statistically meaningful, as they reveal local anomalies that would otherwise be masked in global measures of autocorrelation. A substantial portion of the province, however, remains statistically insignificant (grey areas), indicating that GDP variation in these counties does not depart significantly from spatial randomness.

Taken together, the LISA results reinforce the conclusion that GDP per capita in Hunan is **not randomly distributed**. Instead, there is **evidence of spatial clustering**, with distinct patterns of prosperity in the east and central regions and concentrated underdevelopment in the west. These findings highlight the importance of spatial context in understanding regional inequality and provide a quantitative basis for targeted policy interventions.

:::

## 10.5 Hot Spots and Cold Spots Analysis (HCSA)

### 10.5.1 Deriving distance weight matrix (fixed band with self-inclusion)

#### 10.5.1.1 Computing fixed distance weights

```{r}

ct <- critical_threshold(st_geometry(hunan))   # ensure ≥ 1 neighbour
ct

```

#### 10.5.1.1 Computing fixed distance weights

```{r}

hunan_fdw <- hunan %>%
  mutate(
    nb = include_self(st_dist_band(st_geometry(geometry), upper = ct)),
    wt = st_weights(nb, style = "W"),
    .before = 1
  )

```

#### 10.5.1.2 Computing adaptive distance weights

```{r}

hunan_adw <- hunan %>%
  mutate(nb = include_self(
    st_knn(
      st_geometry(geometry),
      k = 6)),
    wt = st_weights(
      nb, style = "W"),
    .before = 1)

```

### 10.5.2 Computing local Gi*

```{r}

HCSA_fdw <- hunan_fdw %>%
  mutate(
    gistar = local_gstar_perm(
      GDPPC, nb, wt, nsim = 99),
    .before = 1) %>%
  unnest(gistar)

```

### 10.5.3 Preparing and Visualising HCSA Map

#### 10.5.3.1 Mapping Gi* with fix distance weights

```{r}

tm_shape(HCSA_fdw) +
  tm_polygons(fill = "gi_star",
              fill.scale = tm_scale_intervals(
                style = "pretty",
                n = 6,
                values = "brewer.rd_bu"),
              fill.legend = tm_legend(
                title = "Gi*",
                position = tm_pos_out())) + 
  tm_borders(fill_alpha = 0.5) +
  tm_title("Gi* of GDPPC (Fixed Bandwidth d = 60799.91m)")

```

#### 10.5.3.2 Mapping local Gi* p-values

```{r}

tm_shape(HCSA_fdw) +
  tm_polygons(fill = "p_sim", 
              fill.scale = tm_scale_intervals(
                breaks = c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),
                values = "-brewer.Reds"),
              fill.legend = tm_legend(
                title = "simulated p-value",
      position = tm_pos_out())) + 
  tm_borders(fill_alpha = 0.5) +
  tm_title("p-values of local Gi* of GDPPC (Fixed distance)")

```

#### 10.5.3.3 Mapping both Gi* values and p-values


```{r}

Gi_star_map <- tm_shape(HCSA_fdw) +
  tm_polygons(fill = "gi_star",
              fill.scale = tm_scale_intervals(
                style = "pretty",
                n = 5,
                values = "-brewer.rd_bu"),
              fill.legend = tm_legend(
                title = "local Gi*",
                position = tm_pos_in(
                  "left", "bottom"))) + 
  tm_borders(fill_alpha = 0.5) +
  tm_title("Local Gi* of GDPPC")

p_values_map <- tm_shape(HCSA_fdw) +
  tm_polygons(fill = "p_sim", 
              fill.scale = tm_scale_intervals(
                breaks = c(0, 0.001, 0.01, 0.05, 0.1, 1),
                values = "-brewer.reds"),
              fill.legend = tm_legend(
                title = "p-value",
      position = tm_pos_in("left", "bottom")
    )) + 
  tm_borders(fill_alpha = 0.5) +
  tm_title("p-values of local Gi* of GDPPC (fixed distance)")

tmap_arrange(Gi_star_map, p_values_map, asp=1, ncol=2)

```

#### 10.5.3.4 Plotting and visualising HCSA Map


```{r}

HCSA_fdw <- HCSA_fdw %>%
  mutate(HCSA_cluster = case_when(
    p_sim > 0.05 ~ "Insignificant",
    p_sim <= 0.05 & cluster == "High" ~ "Hot spot",
    p_sim <= 0.05 & cluster == "Low"  ~ "Cold spot",
    TRUE ~ "Other"),
    HCSA_cluster = factor(
      HCSA_cluster,
      levels = c("Insignificant", "Hot spot", "Cold spot")
    ),
    .before = 1
  )

```




```{r}

HCSA_map <- tm_shape(HCSA_fdw) + 
  tm_polygons(
    fill = "HCSA_cluster",
    fill.scale = tm_scale_categorical(
      values = c(
        "grey80",      # Insignificant
        "red",        # Low-Low
        "blue"          # High-High
      )
    ),
    fill.legend = tm_legend(
      title = "HSCA Cluster",
      position = tm_pos_in("left", "bottom"))
  ) +
  tm_borders() +
  tm_title("HCSA Clusters (p < 0.05)")
HCSA_map

```

```{r}

tmap_arrange(Gi_star_map, HCSA_map, asp=1, ncol=2)

```

::: {.callout-note icon=false}

### What statistical observations can you draw from the HCSA map above?

**Statistical observations from the HCSA map**

The Hot Spot and Cold Spot Analysis (HCSA) using the Getis-Ord Gi* statistic reveals statistically significant spatial clusters of GDP per capita across Hunan Province. The **hot spots (red areas)** are clearly concentrated in the **eastern and central counties**, where GDP per capita values are significantly higher than would be expected under spatial randomness. These locations are not only economically prosperous on their own but are also surrounded by neighbouring counties with similarly high values, reinforcing spatial clustering of wealth.

In contrast, the **cold spots (blue areas)** are located primarily in the **western and southern parts** of the province. These areas exhibit significantly low GDP per capita values and are surrounded by other low-value counties, forming concentrated zones of economic disadvantage. The identification of cold spots highlights the persistence of underdevelopment in certain regions, particularly those more remote from the provincial economic core.

The remaining counties (grey) are classified as **statistically insignificant**, meaning their GDP per capita patterns do not deviate sufficiently from spatial randomness to be considered clustered.

Overall, the Gi* analysis provides complementary evidence to the LISA results: economic prosperity in Hunan is highly **clustered in the east and central regions**, while underdevelopment is concentrated in the **west and periphery**. This reinforces the presence of **spatial inequality**, suggesting the need for regionally targeted development strategies to reduce the widening gap between hot spots of prosperity and cold spots of persistent poverty.

:::

